2016-09-29  Saam Barati  <sbarati@apple.com>

        We don't properly propagate non-simple-parameter-list when parsing a setter
        https://bugs.webkit.org/show_bug.cgi?id=160483

        Reviewed by Joseph Pecoraro.

        * parser/Parser.cpp:
        (JSC::Parser<LexerType>::parseFunctionParameters):

2016-09-28  Saam Barati  <sbarati@apple.com>

        stringProtoFuncRepeatCharacter will return `null` when it should not
        https://bugs.webkit.org/show_bug.cgi?id=161944

        Reviewed by Yusuke Suzuki.

        stringProtoFuncRepeatCharacter was expecting its second argument
        to always be a boxed integer. This is not correct. The DFG may decide
        to represent a particular value as a double instead of integer. This
        function needs to have correct behavior when its second argument is
        a boxed double. I also added an assertion stating that the second argument
        is always a number. We can guarantee this since it's only called from
        builtins.

        * runtime/StringPrototype.cpp:
        (JSC::stringProtoFuncRepeatCharacter):

2016-09-28  Filip Pizlo  <fpizlo@apple.com>

        The write barrier should be down with TSO
        https://bugs.webkit.org/show_bug.cgi?id=162316

        Reviewed by Geoffrey Garen.
        
        This makes our write barrier behave correctly when it races with the collector. The
        collector wants to do this when visiting:
        
            object->cellState = black
            visit(object)
        
        The mutator wants to do this when storing:
        
            object->property = newValue
            if (object->cellState == black)
                remember(object)
        
        Prior to this change, this didn't work right because the compiler would sometimes place
        barriers before the store to the property and because the mutator did not have adequate
        fences.
        
        Prior to this change, the DFG and FTL would emit this:
        
            if (object->cellState == black)
                remember(object)
            object->property = newValue
        
        Which is wrong, because the object could start being scanned just after the cellState
        check, at which point the store would be lost. We need to confirm that the state was not
        black *after* the store! This change was harder than you'd expect: placing the barrier
        after the store broke B3's ability to do its super crazy ninja CSE on some store-load
        redundancies. Because the B3 CSE has some moves that the DFG CSE lacks, the DFG CSE's
        ability to ignore barriers didn't help. I fixed this by having the FTL convey precise
        heap ranges for the patchpoint corresponding to the barrier slow path. It reads the world
        (because of the store-load fence) and it writes only cellState (because the B3 heap ranges
        don't have any way to represent any of the GC's other state, which means that B3 does not
        have to worry about aliasing with any of that).
        
        The collector already uses a store-load fence on x86 just after setting the cellState and
        before visiting the object. The mutator needs to do the same. But we cannot put a
        store-load fence of any kind before store barriers, because that causes enormous slow
        downs. In the worst case, Octane/richards slowed down by 90%! That's crazy! However, the
        overall slow downs were small enough (0-15% on benchmark suite aggregates) that it would be
        reasonable if the slow down only happened while the GC was running. Then, the concurrent GC
        would lift throughput-while-collecting from 0% of peak to 85% of peak. This changes the
        barrier so that it looks like this:
        
            if (object->cellState <= heap.sneakyBlackThreshold)
                slowPath(object)
        
        Where sneakyBlackThreshold is the normal blackThreshold when we're not collecting, or a
        tautoligical threshold (that makes everything look black) when we are collecting. This
        turns out to not be any more expensive than the barrier in tip of tree when the GC is not
        running, or a 0-15% slow-down when it is "running". (Of course we don't run the GC
        concurrently yet. I still have more work to do.) The slowPath() does some extra work to
        check if we are concurrently collecting; if so, it does a fence and rechecks if the object
        really did need that barrier.
        
        This also reintroduces elimination of redundant store barriers, which was lost in the last
        store barrier change. We can only do it when there is no possibility of GC, exit, or
        exceptions between the two store barriers. We could remove the exit/exception limitation if
        we taught OSR exit how to buffer store barriers, which is an insane thing to do considering
        that I've never been able to detect a win from redundant store barrier elimination. I just
        want us to have it for stupidly obvious situations, like a tight sequence of stores to the
        same object. This same optimization also sometimes strength-reduces the store barrier so
        that it uses a constant black threshold rather than the sneaky one, thereby saving one
        load.
        
        Even with all of those optimizations, I still had problems with barrier cost. I found that one
        of the benchmarks that was being hit particularly hard was JetStream/regexp-2010. Fortunately
        that benchmark does most of its barriers in a tight C++ loop in RegExpMatchesArray.h. When we
        know what we're doing, we can defer GC around a bunch of object initializations and then remove
        all of the barriers between any of the objects allocated within the deferral. Unfortunately,
        our GC deferral mechanism isn't really performant enough to make this be a worthwhile
        optimization. The most efficient version of such an optimization that I could come up with was
        to have a DeferralContext object that houses a boolean that is false by default, but the GC
        writes true into it if it would have wanted to GC. You thread a pointer to the deferralContext
        through all of your allocations. This kind of mechanism has the overhead of a zero 
        initialization on the stack on entry and a zero check on exit. This is probably even efficient
        enough that we could start thinking about having the DFG use it, for example if we found a
        bounded-time section of code with a lot of barriers and entry/exit sites that aren't totally
        wacky. This optimization took this patch from 0.68% JetStream regressed to neutral, according
        to my latest data.
        
        Finally, an earlier version of this change put the store-load fence in B3 IR, so I ended up
        adding FTLOutput support for it and AbstractHeapRepository magic for decorating the heaps.
        I think we might as well keep that, it'll be useful.

        * CMakeLists.txt:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * assembler/MacroAssembler.h:
        (JSC::MacroAssembler::branch32):
        * assembler/MacroAssemblerX86_64.h:
        (JSC::MacroAssemblerX86_64::branch32):
        (JSC::MacroAssemblerX86_64::branch64): Deleted.
        * bytecode/PolymorphicAccess.cpp:
        (JSC::AccessCase::generateImpl):
        * dfg/DFGAbstractHeap.h:
        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGClobbersExitState.cpp:
        (JSC::DFG::clobbersExitState):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGMayExit.cpp:
        * dfg/DFGNode.h:
        (JSC::DFG::Node::isStoreBarrier):
        * dfg/DFGNodeType.h:
        * dfg/DFGPlan.cpp:
        (JSC::DFG::Plan::compileInThreadImpl):
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileStoreBarrier):
        (JSC::DFG::SpeculativeJIT::storeToWriteBarrierBuffer): Deleted.
        (JSC::DFG::SpeculativeJIT::writeBarrier): Deleted.
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        (JSC::DFG::SpeculativeJIT::compileBaseValueStoreBarrier): Deleted.
        (JSC::DFG::SpeculativeJIT::writeBarrier): Deleted.
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        (JSC::DFG::SpeculativeJIT::compileBaseValueStoreBarrier): Deleted.
        (JSC::DFG::SpeculativeJIT::writeBarrier): Deleted.
        * dfg/DFGStoreBarrierClusteringPhase.cpp: Added.
        (JSC::DFG::performStoreBarrierClustering):
        * dfg/DFGStoreBarrierClusteringPhase.h: Added.
        * dfg/DFGStoreBarrierInsertionPhase.cpp:
        * dfg/DFGStoreBarrierInsertionPhase.h:
        * ftl/FTLAbstractHeap.h:
        (JSC::FTL::AbsoluteAbstractHeap::at):
        (JSC::FTL::AbsoluteAbstractHeap::operator[]):
        * ftl/FTLAbstractHeapRepository.cpp:
        (JSC::FTL::AbstractHeapRepository::decorateFenceRead):
        (JSC::FTL::AbstractHeapRepository::decorateFenceWrite):
        (JSC::FTL::AbstractHeapRepository::computeRangesAndDecorateInstructions):
        * ftl/FTLAbstractHeapRepository.h:
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileStoreBarrier):
        (JSC::FTL::DFG::LowerDFGToB3::storageForTransition):
        (JSC::FTL::DFG::LowerDFGToB3::lazySlowPath):
        (JSC::FTL::DFG::LowerDFGToB3::emitStoreBarrier):
        * ftl/FTLOutput.cpp:
        (JSC::FTL::Output::fence):
        (JSC::FTL::Output::absolute):
        * ftl/FTLOutput.h:
        * heap/CellState.h:
        (JSC::isWithinThreshold):
        (JSC::isBlack):
        * heap/Heap.cpp:
        (JSC::Heap::writeBarrierSlowPath):
        * heap/Heap.h:
        (JSC::Heap::barrierShouldBeFenced):
        (JSC::Heap::addressOfBarrierShouldBeFenced):
        (JSC::Heap::sneakyBlackThreshold):
        (JSC::Heap::addressOfSneakyBlackThreshold):
        * heap/HeapInlines.h:
        (JSC::Heap::writeBarrier):
        (JSC::Heap::writeBarrierWithoutFence):
        * jit/AssemblyHelpers.h:
        (JSC::AssemblyHelpers::jumpIfIsRememberedOrInEdenWithoutFence):
        (JSC::AssemblyHelpers::sneakyJumpIfIsRememberedOrInEden):
        (JSC::AssemblyHelpers::jumpIfIsRememberedOrInEden):
        (JSC::AssemblyHelpers::storeBarrierStoreLoadFence):
        (JSC::AssemblyHelpers::jumpIfStoreBarrierStoreLoadFenceNotNeeded):
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emit_op_put_by_id):
        (JSC::JIT::emitWriteBarrier):
        (JSC::JIT::privateCompilePutByVal):
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::emit_op_put_by_id):
        * llint/LowLevelInterpreter.asm:
        * offlineasm/x86.rb:
        * runtime/Options.h:

2016-09-27  Joseph Pecoraro  <pecoraro@apple.com>

        Improve useCodeCache Option description string.

        * runtime/Options.h:
        Address late review comments and clarify description.

2016-09-28  Filip Pizlo  <fpizlo@apple.com>

        Optimize B3->Air lowering of Fence on ARM
        https://bugs.webkit.org/show_bug.cgi?id=162342

        Reviewed by Geoffrey Garen.

        This gives us comprehensive support for standalone fences on x86 and ARM. The changes are as
        follows:

        - Sets in stone the rule that the heaps of a B3::Fence tell you what the fence protects. If the
          fence reads, it protects motion of stores. If the fence writes, it protects motion of loads.
          This allows us to express for example load-load fences in a portable way: on x86 they will just
          block B3 optimizations and emit no code, while on ARM you will get some fence.

        - Adds comprehensive support for WTF-style fences in the ARM assembler. I simplified it just a bit
          to match what B3, the main client, knows. There are three fences: MemoryFence, StoreFence, and
          LoadFence. On x86, MemoryFence is ortop while StoreFence and LoadFence emit no code. On ARM64,
          MemoryFence and LoadFence are dmb ish while StoreFence is dmb ishst.

        - Tests! To test this, I needed to teach the disassembler how to disassemble dmb ish and dmb
          ishst. I think that the canonical way to do it would be to create a group for dmb and then teach
          that group how to decode the operands. But I don't actually know what are all of the ways of
          encoding dmb, so I'd rather that unrecognized encodings fall through to the ".long blah"
          bailout. So, this creates explicit matching rules for "dmb ish" and "dmb ishst", which is the
          most conservative thing we can do.

        * assembler/ARM64Assembler.h:
        (JSC::ARM64Assembler::dmbISH):
        (JSC::ARM64Assembler::dmbISHST):
        (JSC::ARM64Assembler::dmbSY): Deleted.
        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::memoryFence):
        (JSC::MacroAssemblerARM64::storeFence):
        (JSC::MacroAssemblerARM64::loadFence):
        * assembler/MacroAssemblerX86Common.h:
        (JSC::MacroAssemblerX86Common::storeFence):
        (JSC::MacroAssemblerX86Common::loadFence):
        * b3/B3FenceValue.h:
        * b3/B3LowerToAir.cpp:
        (JSC::B3::Air::LowerToAir::lower):
        * b3/air/AirOpcode.opcodes:
        * b3/testb3.cpp:
        (JSC::B3::testMemoryFence):
        (JSC::B3::testStoreFence):
        (JSC::B3::testLoadFence):
        (JSC::B3::run):
        (JSC::B3::testX86MFence): Deleted.
        (JSC::B3::testX86CompilerFence): Deleted.
        * disassembler/ARM64/A64DOpcode.cpp:
        (JSC::ARM64Disassembler::A64DOpcodeDmbIsh::format):
        (JSC::ARM64Disassembler::A64DOpcodeDmbIshSt::format):
        * disassembler/ARM64/A64DOpcode.h:
        (JSC::ARM64Disassembler::A64DOpcodeDmbIsh::opName):
        (JSC::ARM64Disassembler::A64DOpcodeDmbIshSt::opName):

2016-09-28  Joseph Pecoraro  <pecoraro@apple.com>

        Adopt #pragma once in some generated resources
        https://bugs.webkit.org/show_bug.cgi?id=162666

        Reviewed by Alex Christensen.

        * Scripts/builtins/builtins_generate_combined_header.py:
        * Scripts/builtins/builtins_generate_internals_wrapper_header.py:
        * Scripts/builtins/builtins_generate_internals_wrapper_implementation.py:
        * Scripts/builtins/builtins_generate_separate_header.py:
        * Scripts/builtins/builtins_generate_wrapper_header.py:
        * Scripts/builtins/builtins_generate_wrapper_implementation.py:
        Remove headerGuard attribute unused by templates.

        * Scripts/tests/builtins/expected/JavaScriptCore-Operations.Promise-Combined.js-result: Removed.
        No such test exists. It was likely renamed.

        * generate-bytecode-files:
        Simplify header guard output.

        * inspector/scripts/codegen/generate_objc_backend_dispatcher_header.py:
        (ObjCBackendDispatcherHeaderGenerator.generate_output):
        * replay/scripts/CodeGeneratorReplayInputs.py:
        (Generator.generate_header):
        * replay/scripts/CodeGeneratorReplayInputsTemplates.py:
        Simplify header guard output.

        * replay/scripts/tests/expected/generate-enum-encoding-helpers-with-guarded-values.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-enum-encoding-helpers.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-enum-with-guard.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-input-with-guard.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-input-with-vector-members.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-inputs-with-flags.json-TestReplayInputs.h:
        * replay/scripts/tests/expected/generate-memoized-type-modes.json-TestReplayInputs.h:
        Rebaseline.

2016-09-28  Filip Pizlo  <fpizlo@apple.com>

        Store-load fences should be a lot cheaper on ARM
        https://bugs.webkit.org/show_bug.cgi?id=162461

        Rubber stamped by Keith Miller.

        It turns out that they are already cheap enough, so this change just make us use them.

        * heap/SlotVisitor.cpp:
        (JSC::SlotVisitor::visitChildren):

2016-09-28  Ryan Haddad  <ryanhaddad@apple.com>

        Unreviewed, rolling out r206522.

        Roll r206506 back in since the build fix landed in r206521

        Reverted changeset:

        "Unreviewed, rolling out r206506."
        https://bugs.webkit.org/show_bug.cgi?id=162682
        http://trac.webkit.org/changeset/206522

2016-09-28  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r206506.
        https://bugs.webkit.org/show_bug.cgi?id=162682

        Broke the Windows and WinCairo builds. (Requested by
        ryanhaddad on #webkit).

        Reverted changeset:

        "Adopt #pragma once in JavaScriptCore"
        https://bugs.webkit.org/show_bug.cgi?id=162664
        http://trac.webkit.org/changeset/206506

2016-09-28  Joseph Pecoraro  <pecoraro@apple.com>

        Adopt #pragma once in JavaScriptCore
        https://bugs.webkit.org/show_bug.cgi?id=162664

        Reviewed by Saam Barati.

        * **/**.h:
        Adopt pragma once in all but API headers and generated headers.
        Include some namespace closing comments for consistency.

2016-09-27  JF Bastien  <jfbastien@apple.com>

        Missing Atomics.h include in MarkedBlock.h
        https://bugs.webkit.org/show_bug.cgi?id=162648

        Missing include from my previous patch.

        Reviewed by Yusuke Suzuki.

        * heap/MarkedBlock.h:

2016-09-27  Mark Lam  <mark.lam@apple.com>

        createError() and JSObject::calculatedClassName() should not throw any exceptions.
        https://bugs.webkit.org/show_bug.cgi?id=162637

        Reviewed by Geoffrey Garen.

        * runtime/ExceptionHelpers.cpp:
        (JSC::createError):
        - assert that errorDescriptionForValue() did not throw an exception.

        * runtime/JSObject.cpp:
        (JSC::JSObject::calculatedClassName):
        - the code already ensures that we always return a non-null String.  Just need to
          make sure that it catches its own exceptions.

2016-09-27  Filip Pizlo  <fpizlo@apple.com>

        B3::lowerMacros forgets to before->updatePredecessorsAfter() when lowering ChillMod on ARM64
        https://bugs.webkit.org/show_bug.cgi?id=162644

        Reviewed by Keith Miller.

        If you forget to update the predecessors of your successors, then bad things will happen if you
        do something that requires accurate predecessors for correctness. lowerMacros() uses
        BlockInsertionSet, which relies on accurate predecessors.

        * b3/B3LowerMacros.cpp:

2016-09-27  JF Bastien  <jfbastien@apple.com>

        Speed up Heap::isMarkedConcurrently
        https://bugs.webkit.org/show_bug.cgi?id=162095

        Reviewed by Filip Pizlo.

        Speed up isMarkedConcurrently by using WTF::consumeLoad.

        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::areMarksStale):
        (JSC::MarkedBlock::areMarksStaleWithDependency):
        (JSC::MarkedBlock::isMarkedConcurrently): do away with the load-load fence

2016-09-27  Mark Lam  <mark.lam@apple.com>

        Add some needed CatchScopes in code that should not throw.
        https://bugs.webkit.org/show_bug.cgi?id=162584

        Reviewed by Keith Miller.

        Re-landing minus the jsc.cpp and ExceptionHelpers.cpp changes.  I'll address
        those in a subsequent patch if the need manifests again in my testing.

        * API/JSObjectRef.cpp:
        (JSObjectSetProperty):
        - This function already handles exceptions in its own way.  We're honoring this
          contract and catching exceptions and passing it to the handler.

        * interpreter/Interpreter.cpp:
        (JSC::notifyDebuggerOfUnwinding):
        - The debugger should not be throwing any exceptions.

        * profiler/ProfilerDatabase.cpp:
        (JSC::Profiler::Database::save):
        - If an exception was thrown while saving the database, there's nothing we can
          really do about it anyway.  Just fail nicely and return false.  This is in line
          with existing error checking code in Database::save() that returns false if
          it's not able to open the file to save to.

        * runtime/JSModuleLoader.cpp:
        (JSC::JSModuleLoader::finishCreation):
        - The existing code already RELEASE_ASSERT that no exception was thrown.
          Hence, it's appropriate to use a CatchScope here.

        * runtime/SamplingProfiler.cpp:
        (JSC::SamplingProfiler::StackFrame::nameFromCallee):
        - The sampling profiler is doing a VMInquiry get here.  It should never throw an
          exception.  Hence, we'll just use a CatchScope and assert accordingly.

2016-09-27  Jer Noble  <jer.noble@apple.com>

        Remove deprecated ENCRYPTED_MEDIA implementation.
        https://bugs.webkit.org/show_bug.cgi?id=161010

        Reviewed by Eric Carlson.

        Remove ENABLE_ENCRYPTED_MEDIA.

        * Configurations/FeatureDefines.xcconfig:

2016-09-27  Michael Catanzaro  <mcatanzaro@igalia.com>

        [GTK] Install binaries to pkglibexecdir rather than bindir
        https://bugs.webkit.org/show_bug.cgi?id=162602

        Reviewed by Carlos Garcia Campos.

        Install jsc shell to LIBEXEC_INSTALL_DIR rather than EXEC_INSTALL_DIR.

        Note these locations are the same on non-GTK ports.

        * shell/CMakeLists.txt:

2016-09-26  Sam Weinig  <sam@webkit.org>

        Make DFGSlowPathGenerator a bit more variadic
        https://bugs.webkit.org/show_bug.cgi?id=162378

        Reviewed by Filip Pizlo.

        Make the subclass of CallSlowPathGenerator that takes arguments variadic
        so it can take any number of arguments. Also updates the slowPathCall helper
        function to be variadic. I had to move the spill mode and exception check 
        requirement parameters to before the arguments since the variadic arguments
        must be at the end. As a convenience, I added an overload of slowPathCall that
        doesn't take spill mode and exception check requirement parameters.

        * dfg/DFGSlowPathGenerator.h:
        (JSC::DFG::CallResultAndArgumentsSlowPathGenerator::CallResultAndArgumentsSlowPathGenerator):
        (JSC::DFG::CallResultAndArgumentsSlowPathGenerator::unpackAndGenerate):
        (JSC::DFG::slowPathCall):
        (JSC::DFG::CallResultAndNoArgumentsSlowPathGenerator::CallResultAndNoArgumentsSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndOneArgumentSlowPathGenerator::CallResultAndOneArgumentSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndTwoArgumentsSlowPathGenerator::CallResultAndTwoArgumentsSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndThreeArgumentsSlowPathGenerator::CallResultAndThreeArgumentsSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndFourArgumentsSlowPathGenerator::CallResultAndFourArgumentsSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndFourArgumentsSlowPathGenerator::generateInternal): Deleted.
        (JSC::DFG::CallResultAndFiveArgumentsSlowPathGenerator::CallResultAndFiveArgumentsSlowPathGenerator): Deleted.
        (JSC::DFG::CallResultAndFiveArgumentsSlowPathGenerator::generateInternal): Deleted.
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileValueToInt32):
        (JSC::DFG::SpeculativeJIT::compileNotifyWrite):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::cachedGetById):

2016-09-26  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r206405.
        https://bugs.webkit.org/show_bug.cgi?id=162588

        This change caused LayoutTest crashes. (Requested by
        ryanhaddad on #webkit).

        Reverted changeset:

        "Add some needed CatchScopes in code that should not throw."
        https://bugs.webkit.org/show_bug.cgi?id=162584
        http://trac.webkit.org/changeset/206405

2016-09-26  Mark Lam  <mark.lam@apple.com>

        Add some needed CatchScopes in code that should not throw.
        https://bugs.webkit.org/show_bug.cgi?id=162584

        Reviewed by Keith Miller.

        * API/JSObjectRef.cpp:
        (JSObjectSetProperty):
        - This function already handles exceptions in its own way.  We're honoring this
          contract and catching exceptions and passing it to the handler.

        * interpreter/Interpreter.cpp:
        (JSC::notifyDebuggerOfUnwinding):
        - The debugger should not be throwing any exceptions.

        * jsc.cpp:
        (runJSC):
        - the buck stops here.  There's no reason an exception should propagate past here.

        * profiler/ProfilerDatabase.cpp:
        (JSC::Profiler::Database::save):
        - If an exception was thrown while saving the database, there's nothing we can
          really do about it anyway.  Just fail nicely and return false.  This is in line
          with existing error checking code in Database::save() that returns false if
          it's not able to open the file to save to.

        * runtime/ExceptionHelpers.cpp:
        (JSC::createError):
        - If we're not able to stringify the error value, then we'll just use the
          provided message as the error string.  It doesn't make sense to have the
          Error factory throw an exception that shadows the intended exception that the
          client probably wants to throw (assuming that that's why the client is creating
          this Error object).

        * runtime/JSModuleLoader.cpp:
        (JSC::JSModuleLoader::finishCreation):
        - The existing code already RELEASE_ASSERT that no exception was thrown.
          Hence, it's appropriate to use a CatchScope here.

        * runtime/SamplingProfiler.cpp:
        (JSC::SamplingProfiler::StackFrame::nameFromCallee):
        - The sampling profiler is doing a VMInquiry get here.  It should never throw an
          exception.  Hence, we'll just use a CatchScope and assert accordingly.

2016-09-26  Mark Lam  <mark.lam@apple.com>

        Exception unwinding code should use a CatchScope instead of a ThrowScope.
        https://bugs.webkit.org/show_bug.cgi?id=162583

        Reviewed by Geoffrey Garen.

        This is because the exception unwinding code does not throw an exception.
        It only inspects the thrown exception and passes it to the appropriate handler.

        * interpreter/Interpreter.cpp:
        (JSC::Interpreter::unwind):
        * jit/JITExceptions.cpp:
        (JSC::genericUnwind):

2016-09-26  Joseph Pecoraro  <pecoraro@apple.com>

        Add an Option to disable the CodeCache
        https://bugs.webkit.org/show_bug.cgi?id=162579

        Reviewed by Geoffrey Garen.

        * runtime/CodeCache.cpp:
        (JSC::CodeCache::getGlobalCodeBlock):
        (JSC::CodeCache::getFunctionExecutableFromGlobalCode):
        Do not use the cache if the Option is disabled.

        * runtime/Options.h:
        New option to not use the code cache.

2016-09-26  Daniel Bates  <dabates@apple.com>

        Rename IOS_TEXT_AUTOSIZING to TEXT_AUTOSIZING
        https://bugs.webkit.org/show_bug.cgi?id=162365

        Reviewed by Simon Fraser.

        * Configurations/FeatureDefines.xcconfig:

2016-09-26  Benjamin Poulain  <benjamin@webkit.org>

        [JSC] Shrink the Math inline caches some more
        https://bugs.webkit.org/show_bug.cgi?id=162485

        Reviewed by Saam Barati.

        This patch applies some lessons learnt from op_negate
        to shrink the generated asm of the previous 3 inline
        caches.

        In order of importance:
        -We do not need to pass the pointer to ArithProfile
         on the slow path. We can just get the profile out
         of the Math IC.
         This saves us from materializing a 64bits value
         in a register before the call on the slow path.
        -We can remove a bunch of mov by setting up the registers
         in the way the slow path needs them.
         The slow path makes a function calls with the input
         as second and third arguments, and return the result in
         the "return register". By using those as target when
         loading/storing from the stack, we remove 3 mov per slow path.
        -When performing integer add, we can set the result directly in
         the output register if that does not trashes one of the input
         register. This removes one mov per integer add.

        The inline cache average sizes on Sunspider change as follow:
        -Adds: 147.573099->131.555556 (~10%)
        -Muls: 186.882353->170.991597 (~8%)
        -Subs: 139.127907->121.523256 (~12%)

        * jit/JIT.h:
        * jit/JITAddGenerator.cpp:
        (JSC::JITAddGenerator::generateInline):
        (JSC::JITAddGenerator::generateFastPath):
        * jit/JITArithmetic.cpp:
        (JSC::JIT::emitMathICFast):
        (JSC::JIT::emitMathICSlow):
        * jit/JITInlines.h:
        (JSC::JIT::callOperation): Deleted.
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:

2016-09-26  Mark Lam  <mark.lam@apple.com>

        Added RETURN_IF_EXCEPTION() macro and use it for exception checks.
        https://bugs.webkit.org/show_bug.cgi?id=162521

        Reviewed by Saam Barati.

        Also, where possible, if the return type is JSValue, changed the returned value
        (on exception) to the empty JSValue (instead of sometimes jsUndefined, jsNull,
        or the thrown exception value).

        There are a few places where I had to continue to return the previously returned
        value (instead of the empty JSValue) in order for tests to pass.  This is needed
        because there are missing exception checks that will need to be added before I
        can change those to return the empty JSValue too.  Identifying all the places
        where those checks need to be added is beyond the scope of this patch.  I will
        work on adding missing exception checks in a subsequent patch.

        In this patch, there is one missing exception check in replaceUsingRegExpSearch()
        that was easily identified, and is necessary so that Interpreter::execute()
        functions can return JSValue.  I've added this missing check.

        This patch has passed the JSC and layout tests.

        * dfg/DFGOperations.cpp:
        (JSC::DFG::operationPutByValInternal):
        * inspector/JSInjectedScriptHost.cpp:
        (Inspector::JSInjectedScriptHost::evaluateWithScopeExtension):
        (Inspector::JSInjectedScriptHost::getInternalProperties):
        (Inspector::JSInjectedScriptHost::weakMapEntries):
        (Inspector::JSInjectedScriptHost::weakSetEntries):
        (Inspector::JSInjectedScriptHost::iteratorEntries):
        * inspector/JSJavaScriptCallFrame.cpp:
        (Inspector::JSJavaScriptCallFrame::evaluateWithScopeExtension):
        * interpreter/Interpreter.cpp:
        (JSC::eval):
        (JSC::sizeOfVarargs):
        (JSC::Interpreter::execute):
        (JSC::Interpreter::executeCall):
        (JSC::Interpreter::executeConstruct):
        * interpreter/ShadowChicken.cpp:
        (JSC::ShadowChicken::functionsOnStack):
        * jit/JITOperations.cpp:
        (JSC::getByVal):
        * jsc.cpp:
        (WTF::ImpureGetter::getOwnPropertySlot):
        (functionRun):
        (functionRunString):
        (functionLoad):
        (functionLoadString):
        (functionReadFile):
        (functionCheckSyntax):
        (functionSetRandomSeed):
        (functionLoadModule):
        (functionCreateBuiltin):
        (functionCheckModuleSyntax):
        * llint/LLIntSlowPaths.cpp:
        (JSC::LLInt::getByVal):
        (JSC::LLInt::LLINT_SLOW_PATH_DECL):
        * profiler/ProfilerBytecodeSequence.cpp:
        (JSC::Profiler::BytecodeSequence::addSequenceProperties):
        * profiler/ProfilerCompilation.cpp:
        (JSC::Profiler::Compilation::toJS):
        * profiler/ProfilerDatabase.cpp:
        (JSC::Profiler::Database::toJS):
        * profiler/ProfilerOSRExitSite.cpp:
        (JSC::Profiler::OSRExitSite::toJS):
        * profiler/ProfilerOriginStack.cpp:
        (JSC::Profiler::OriginStack::toJS):
        * runtime/ArrayPrototype.cpp:
        (JSC::speciesConstructArray):
        (JSC::shift):
        (JSC::unshift):
        (JSC::arrayProtoFuncToString):
        (JSC::arrayProtoFuncToLocaleString):
        (JSC::slowJoin):
        (JSC::fastJoin):
        (JSC::arrayProtoFuncJoin):
        (JSC::arrayProtoFuncPop):
        (JSC::arrayProtoFuncPush):
        (JSC::arrayProtoFuncReverse):
        (JSC::arrayProtoFuncShift):
        (JSC::arrayProtoFuncSlice):
        (JSC::arrayProtoFuncSplice):
        (JSC::arrayProtoFuncUnShift):
        (JSC::arrayProtoFuncIndexOf):
        (JSC::arrayProtoFuncLastIndexOf):
        (JSC::moveElements):
        (JSC::arrayProtoPrivateFuncConcatMemcpy):
        * runtime/BooleanConstructor.cpp:
        (JSC::constructWithBooleanConstructor):
        * runtime/CommonSlowPaths.h:
        (JSC::CommonSlowPaths::opIn):
        * runtime/Completion.cpp:
        (JSC::loadAndEvaluateModule):
        (JSC::loadModule):
        * runtime/ConsoleObject.cpp:
        (JSC::consoleProtoFuncAssert):
        (JSC::consoleProtoFuncProfile):
        (JSC::consoleProtoFuncProfileEnd):
        (JSC::consoleProtoFuncTakeHeapSnapshot):
        (JSC::consoleProtoFuncTime):
        (JSC::consoleProtoFuncTimeEnd):
        * runtime/DateConstructor.cpp:
        (JSC::constructDate):
        (JSC::dateParse):
        * runtime/DatePrototype.cpp:
        (JSC::dateProtoFuncToPrimitiveSymbol):
        (JSC::dateProtoFuncToJSON):
        * runtime/ErrorConstructor.cpp:
        (JSC::Interpreter::constructWithErrorConstructor):
        * runtime/ErrorInstance.cpp:
        (JSC::ErrorInstance::sanitizedToString):
        * runtime/ErrorPrototype.cpp:
        (JSC::errorProtoFuncToString):
        * runtime/ExceptionScope.h:
        * runtime/FunctionConstructor.cpp:
        (JSC::constructFunctionSkippingEvalEnabledCheck):
        * runtime/GenericArgumentsInlines.h:
        (JSC::GenericArguments<Type>::copyToArguments):
        * runtime/GetterSetter.cpp:
        (JSC::callGetter):
        * runtime/HashMapImpl.h:
        (JSC::jsMapHash):
        (JSC::HashMapImpl::finishCreation):
        (JSC::HashMapImpl::findBucket):
        (JSC::HashMapImpl::add):
        (JSC::HashMapImpl::rehash):
        * runtime/InspectorInstrumentationObject.cpp:
        (JSC::inspectorInstrumentationObjectLog):
        * runtime/InternalFunction.cpp:
        (JSC::InternalFunction::createSubclassStructure):
        * runtime/IntlCollator.cpp:
        (JSC::IntlCollator::initializeCollator):
        * runtime/IntlCollatorConstructor.cpp:
        (JSC::constructIntlCollator):
        (JSC::IntlCollatorConstructorFuncSupportedLocalesOf):
        * runtime/IntlCollatorPrototype.cpp:
        (JSC::IntlCollatorFuncCompare):
        (JSC::IntlCollatorPrototypeGetterCompare):
        * runtime/IntlDateTimeFormat.cpp:
        (JSC::toDateTimeOptionsAnyDate):
        (JSC::IntlDateTimeFormat::initializeDateTimeFormat):
        * runtime/IntlDateTimeFormatConstructor.cpp:
        (JSC::constructIntlDateTimeFormat):
        (JSC::IntlDateTimeFormatConstructorFuncSupportedLocalesOf):
        * runtime/IntlDateTimeFormatPrototype.cpp:
        (JSC::IntlDateTimeFormatFuncFormatDateTime):
        (JSC::IntlDateTimeFormatPrototypeGetterFormat):
        * runtime/IntlNumberFormat.cpp:
        (JSC::IntlNumberFormat::initializeNumberFormat):
        * runtime/IntlNumberFormatConstructor.cpp:
        (JSC::constructIntlNumberFormat):
        (JSC::IntlNumberFormatConstructorFuncSupportedLocalesOf):
        * runtime/IntlNumberFormatPrototype.cpp:
        (JSC::IntlNumberFormatFuncFormatNumber):
        (JSC::IntlNumberFormatPrototypeGetterFormat):
        * runtime/IntlObject.cpp:
        (JSC::intlBooleanOption):
        (JSC::intlStringOption):
        (JSC::intlNumberOption):
        (JSC::canonicalizeLocaleList):
        (JSC::supportedLocales):
        * runtime/IntlObjectInlines.h:
        (JSC::constructIntlInstanceWithWorkaroundForLegacyIntlConstructor):
        * runtime/IteratorOperations.cpp:
        (JSC::iteratorNext):
        (JSC::iteratorStep):
        (JSC::iteratorClose):
        (JSC::iteratorForIterable):
        * runtime/IteratorOperations.h:
        (JSC::forEachInIterable):
        * runtime/JSArray.cpp:
        (JSC::JSArray::pop):
        (JSC::JSArray::copyToArguments):
        * runtime/JSArrayBufferConstructor.cpp:
        (JSC::constructArrayBuffer):
        * runtime/JSArrayBufferPrototype.cpp:
        (JSC::arrayBufferProtoFuncSlice):
        * runtime/JSArrayInlines.h:
        (JSC::getLength):
        (JSC::toLength):
        * runtime/JSBoundFunction.cpp:
        (JSC::getBoundFunctionStructure):
        (JSC::JSBoundFunction::create):
        * runtime/JSCJSValue.cpp:
        (JSC::JSValue::putToPrimitive):
        (JSC::JSValue::toStringSlowCase):
        * runtime/JSCJSValueInlines.h:
        (JSC::toPreferredPrimitiveType):
        (JSC::JSValue::getPropertySlot):
        (JSC::JSValue::equalSlowCaseInline):
        * runtime/JSDataViewPrototype.cpp:
        (JSC::getData):
        (JSC::setData):
        * runtime/JSFunction.cpp:
        (JSC::JSFunction::setFunctionName):
        * runtime/JSGenericTypedArrayView.h:
        (JSC::JSGenericTypedArrayView::setIndex):
        * runtime/JSGenericTypedArrayViewConstructorInlines.h:
        (JSC::constructGenericTypedArrayViewFromIterator):
        (JSC::constructGenericTypedArrayViewWithArguments):
        (JSC::constructGenericTypedArrayView):
        * runtime/JSGenericTypedArrayViewPrototypeFunctions.h:
        (JSC::speciesConstruct):
        (JSC::genericTypedArrayViewProtoFuncSet):
        (JSC::genericTypedArrayViewProtoFuncCopyWithin):
        (JSC::genericTypedArrayViewProtoFuncIncludes):
        (JSC::genericTypedArrayViewProtoFuncIndexOf):
        (JSC::genericTypedArrayViewProtoFuncJoin):
        (JSC::genericTypedArrayViewProtoFuncLastIndexOf):
        (JSC::genericTypedArrayViewProtoFuncSlice):
        (JSC::genericTypedArrayViewPrivateFuncSubarrayCreate):
        * runtime/JSGlobalObject.h:
        (JSC::constructEmptyArray):
        (JSC::constructArray):
        (JSC::constructArrayNegativeIndexed):
        * runtime/JSGlobalObjectFunctions.cpp:
        (JSC::globalFuncEval):
        * runtime/JSModuleRecord.cpp:
        (JSC::JSModuleRecord::instantiateDeclarations):
        * runtime/JSONObject.cpp:
        (JSC::Stringifier::stringify):
        (JSC::Stringifier::toJSON):
        (JSC::Stringifier::appendStringifiedValue):
        (JSC::Stringifier::Holder::appendNextProperty):
        (JSC::Walker::walk):
        (JSC::JSONProtoFuncParse):
        * runtime/JSObject.cpp:
        (JSC::ordinarySetSlow):
        (JSC::JSObject::setPrototypeWithCycleCheck):
        (JSC::callToPrimitiveFunction):
        (JSC::JSObject::defaultHasInstance):
        (JSC::JSObject::getPropertyNames):
        (JSC::JSObject::toNumber):
        (JSC::JSObject::toString):
        (JSC::JSObject::defineOwnNonIndexProperty):
        (JSC::JSObject::getGenericPropertyNames):
        (JSC::JSObject::getMethod):
        * runtime/JSObjectInlines.h:
        (JSC::createListFromArrayLike):
        (JSC::JSObject::getPropertySlot):
        (JSC::JSObject::getNonIndexPropertySlot):
        * runtime/JSPromiseConstructor.cpp:
        (JSC::constructPromise):
        * runtime/JSPromiseDeferred.cpp:
        (JSC::JSPromiseDeferred::create):
        * runtime/JSPropertyNameEnumerator.h:
        (JSC::propertyNameEnumerator):
        * runtime/JSPropertyNameIterator.cpp:
        (JSC::JSPropertyNameIterator::create):
        * runtime/JSScope.cpp:
        (JSC::isUnscopable):
        * runtime/JSString.cpp:
        (JSC::JSString::equalSlowCase):
        * runtime/JSStringJoiner.cpp:
        (JSC::JSStringJoiner::join):
        * runtime/LiteralParser.cpp:
        (JSC::LiteralParser<CharType>::parse):
        * runtime/MapBase.h:
        (JSC::MapBase::finishCreation):
        * runtime/MapConstructor.cpp:
        (JSC::constructMap):
        * runtime/MathObject.cpp:
        (JSC::mathProtoFuncClz32):
        (JSC::mathProtoFuncHypot):
        (JSC::mathProtoFuncIMul):
        * runtime/ModuleLoaderPrototype.cpp:
        (JSC::moduleLoaderPrototypeParseModule):
        (JSC::moduleLoaderPrototypeRequestedModules):
        (JSC::moduleLoaderPrototypeModuleDeclarationInstantiation):
        * runtime/NativeErrorConstructor.cpp:
        (JSC::Interpreter::constructWithNativeErrorConstructor):
        * runtime/NumberConstructor.cpp:
        (JSC::constructWithNumberConstructor):
        * runtime/ObjectConstructor.cpp:
        (JSC::constructObject):
        (JSC::objectConstructorGetPrototypeOf):
        (JSC::objectConstructorSetPrototypeOf):
        (JSC::objectConstructorGetOwnPropertyDescriptor):
        (JSC::objectConstructorGetOwnPropertyDescriptors):
        (JSC::objectConstructorGetOwnPropertyNames):
        (JSC::objectConstructorGetOwnPropertySymbols):
        (JSC::objectConstructorKeys):
        (JSC::ownEnumerablePropertyKeys):
        (JSC::toPropertyDescriptor):
        (JSC::objectConstructorDefineProperty):
        (JSC::defineProperties):
        (JSC::objectConstructorSeal):
        (JSC::objectConstructorFreeze):
        (JSC::objectConstructorIsSealed):
        (JSC::objectConstructorIsFrozen):
        (JSC::objectConstructorIsExtensible):
        (JSC::ownPropertyKeys):
        * runtime/ObjectConstructor.h:
        (JSC::constructObjectFromPropertyDescriptor):
        * runtime/ObjectPrototype.cpp:
        (JSC::objectProtoFuncHasOwnProperty):
        (JSC::objectProtoFuncIsPrototypeOf):
        (JSC::objectProtoFuncDefineGetter):
        (JSC::objectProtoFuncDefineSetter):
        (JSC::objectProtoFuncLookupGetter):
        (JSC::objectProtoFuncLookupSetter):
        (JSC::objectProtoFuncPropertyIsEnumerable):
        (JSC::objectProtoFuncToLocaleString):
        (JSC::objectProtoFuncToString):
        * runtime/Operations.cpp:
        (JSC::jsAddSlowCase):
        * runtime/PropertyDescriptor.cpp:
        (JSC::PropertyDescriptor::slowGetterSetter):
        * runtime/ProxyConstructor.cpp:
        (JSC::makeRevocableProxy):
        * runtime/ProxyObject.cpp:
        (JSC::performProxyGet):
        (JSC::ProxyObject::performGet):
        (JSC::ProxyObject::performInternalMethodGetOwnProperty):
        (JSC::ProxyObject::performHasProperty):
        (JSC::ProxyObject::performPut):
        (JSC::ProxyObject::putByIndexCommon):
        (JSC::performProxyCall):
        (JSC::performProxyConstruct):
        (JSC::ProxyObject::performDelete):
        (JSC::ProxyObject::performPreventExtensions):
        (JSC::ProxyObject::performIsExtensible):
        (JSC::ProxyObject::performDefineOwnProperty):
        (JSC::ProxyObject::performGetOwnPropertyNames):
        (JSC::ProxyObject::performSetPrototype):
        (JSC::ProxyObject::performGetPrototype):
        * runtime/ReflectObject.cpp:
        (JSC::reflectObjectConstruct):
        (JSC::reflectObjectDefineProperty):
        (JSC::reflectObjectGet):
        (JSC::reflectObjectGetOwnPropertyDescriptor):
        (JSC::reflectObjectIsExtensible):
        (JSC::reflectObjectPreventExtensions):
        (JSC::reflectObjectSet):
        (JSC::reflectObjectSetPrototypeOf):
        * runtime/RegExpConstructor.cpp:
        (JSC::toFlags):
        (JSC::regExpCreate):
        (JSC::constructRegExp):
        * runtime/RegExpConstructor.h:
        (JSC::isRegExp):
        * runtime/RegExpObject.cpp:
        (JSC::collectMatches):
        (JSC::RegExpObject::matchGlobal):
        * runtime/RegExpPrototype.cpp:
        (JSC::regExpProtoFuncCompile):
        (JSC::flagsString):
        (JSC::regExpProtoFuncToString):
        (JSC::regExpProtoGetterFlags):
        (JSC::regExpProtoFuncSearchFast):
        (JSC::regExpProtoFuncSplitFast):
        * runtime/SetConstructor.cpp:
        (JSC::constructSet):
        * runtime/StringConstructor.cpp:
        (JSC::stringFromCodePoint):
        (JSC::constructWithStringConstructor):
        * runtime/StringObject.cpp:
        (JSC::StringObject::defineOwnProperty):
        * runtime/StringPrototype.cpp:
        (JSC::replaceUsingRegExpSearch):
        (JSC::operationStringProtoFuncReplaceRegExpEmptyStr):
        (JSC::replaceUsingStringSearch):
        (JSC::replace):
        (JSC::stringProtoFuncReplaceUsingRegExp):
        (JSC::stringProtoFuncReplaceUsingStringSearch):
        (JSC::stringProtoFuncCodePointAt):
        (JSC::stringProtoFuncSlice):
        (JSC::stringProtoFuncSplitFast):
        (JSC::stringProtoFuncSubstr):
        (JSC::stringProtoFuncSubstring):
        (JSC::stringProtoFuncLocaleCompare):
        (JSC::toLocaleCase):
        (JSC::stringProtoFuncBig):
        (JSC::stringProtoFuncSmall):
        (JSC::stringProtoFuncBlink):
        (JSC::stringProtoFuncBold):
        (JSC::stringProtoFuncFixed):
        (JSC::stringProtoFuncItalics):
        (JSC::stringProtoFuncStrike):
        (JSC::stringProtoFuncSub):
        (JSC::stringProtoFuncSup):
        (JSC::stringProtoFuncFontcolor):
        (JSC::stringProtoFuncFontsize):
        (JSC::stringProtoFuncAnchor):
        (JSC::stringProtoFuncLink):
        (JSC::trimString):
        (JSC::stringProtoFuncStartsWith):
        (JSC::stringProtoFuncEndsWith):
        (JSC::stringIncludesImpl):
        (JSC::stringProtoFuncIncludes):
        (JSC::builtinStringIncludesInternal):
        (JSC::stringProtoFuncNormalize):
        * runtime/SymbolConstructor.cpp:
        (JSC::symbolConstructorFor):
        * runtime/TemplateRegistry.cpp:
        (JSC::TemplateRegistry::getTemplateObject):
        * runtime/WeakMapConstructor.cpp:
        (JSC::constructWeakMap):
        * runtime/WeakSetConstructor.cpp:
        (JSC::constructWeakSet):
        * tools/JSDollarVMPrototype.cpp:
        (JSC::functionPrint):

2016-09-26  Don Olmstead  <don.olmstead@am.sony.com>

        [JSC] Allow fixedExecutableMemoryPoolSize to be set during build
        https://bugs.webkit.org/show_bug.cgi?id=162514

        Reviewed by Mark Lam.

        * jit/ExecutableAllocator.h:

== Rolled over to ChangeLog-2016-09-26 ==
